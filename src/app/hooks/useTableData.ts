'use client'

/**
 * ============================================================
 * 统一数据层 (Unified Data Layer) - 核心重构代码
 *
 * ⚠️ 警告：此文件为Schema驱动数据层核心勿直接修改，请
 *
 * 已重构页面应通过此Hook获取数据，禁止直接访问飞书API
 * 如需变更字段处理逻辑，请联系架构负责人
 *
 * 允许修改的场景：
 *   - 新增字段类型适配器 (field-adapters.ts)
 *   - Bug修复 (请先咨询)
 *   - 性能优化 (请先咨询)
 *
 * 禁止修改的场景：
 *   - 直接添加页面特定逻辑
 *   - 硬编码字段名
 *   - 绕过此Hook直接调用API
 * ============================================================
 */

import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react'
import type { TableSchema } from './useTableSchema'

/** 客户端缓存：tableId -> { schema, records, ts }，TTL 45s，订单/物流同表可复用 */
const CACHE_TTL_MS = 45_000
const clientCache = new Map<
  string,
  { schema: unknown; records: unknown[]; ts: number }
>()
import {
  categorizeFields,
  applyFieldMappingBatch,
  type MappedField,
  type FieldCategory,
  type FieldFormat
} from '@/lib/feishu/field-mapping'

export interface ProcessedField {
  raw: unknown
  parsed: unknown
  formatted: string
  meta: MappedField
  isFormula: boolean
  isEmpty: boolean
}

export interface TableRecord {
  recordId: string
  fields: Record<string, ProcessedField>
  raw: Record<string, unknown>
}

export interface UseTableDataOptions {
  tableId: string
  moduleId?: string
  filter?: (record: TableRecord) => boolean
  transform?: (record: TableRecord) => TableRecord
  enableCache?: boolean
}

export interface UseTableDataReturn {
  records: TableRecord[]
  schema: TableSchema | null
  mappedFields: MappedField[]
  categorizedFields: Record<FieldCategory, MappedField[]>
  loading: boolean
  error: Error | null
  refetch: () => Promise<void>
  stats: {
    totalRecords: number
    totalFields: number
    mappedFields: number
    autoGeneratedFields: number
  }
}

export function useTableData(options: UseTableDataOptions): UseTableDataReturn {
  const { tableId, filter, transform, enableCache = true } = options
  
  const [schema, setSchema] = useState<TableSchema | null>(null)
  const [records, setRecords] = useState<TableRecord[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const filterRef = React.useRef(filter)
  const transformRef = React.useRef(transform)
  const requestIdRef = React.useRef(0)
  const lastRetriedTableIdRef = React.useRef<string | null>(null)

  React.useEffect(() => {
    filterRef.current = filter
    transformRef.current = transform
  }, [filter, transform])

  const fetchData = useCallback(async (forceNoCache = false) => {
    const validTableId = tableId && tableId.trim().length > 0
    if (!validTableId) {
      setSchema(null)
      setRecords([])
      setLoading(false)
      return
    }

    const reqId = ++requestIdRef.current

    // 命中客户端缓存且未过期时，直接使用
    if (enableCache && !forceNoCache) {
      const cached = clientCache.get(tableId)
      if (cached && Date.now() - cached.ts < CACHE_TTL_MS) {
        const rawRecords = cached.records as TableRecord[]
        const transformed = transformRef.current
          ? rawRecords.map((r) => transformRef.current!(r))
          : rawRecords
        const filtered = filterRef.current ? transformed.filter(filterRef.current) : transformed
        setSchema(cached.schema as TableSchema | null)
        setRecords(filtered)
        setLoading(false)
        setError(null)
        return
      }
    }

    setLoading(true)
    setError(null)

    try {
      const res = await fetch(
        `/api/table?tableId=${encodeURIComponent(tableId)}`,
        { cache: 'no-store' }
      )
      if (reqId !== requestIdRef.current) return
      if (!res.ok) throw new Error(`HTTP ${res.status}`)
      const data = await res.json()
      if (reqId !== requestIdRef.current) return
      const schemaJson = data.schema ?? null
      const rawRecords: TableRecord[] = Array.isArray(data.records) ? data.records : []
      const transformed = transformRef.current
        ? rawRecords.map((r) => transformRef.current!(r))
        : rawRecords
      const filtered = filterRef.current ? transformed.filter(filterRef.current) : transformed
      setSchema(schemaJson)
      setRecords(filtered)
      if (enableCache && schemaJson && rawRecords.length >= 0) {
        clientCache.set(tableId, { schema: schemaJson, records: rawRecords, ts: Date.now() })
      }
      if (reqId === requestIdRef.current && validTableId && !schemaJson && res.ok && lastRetriedTableIdRef.current !== tableId) {
        lastRetriedTableIdRef.current = tableId
        setTimeout(() => { if (requestIdRef.current === reqId) fetchData(true) }, 400)
      }
    } catch (err) {
      if (reqId !== requestIdRef.current) return
      setError(err instanceof Error ? err : new Error('Failed to fetch data'))
      setRecords([])
    } finally {
      if (reqId === requestIdRef.current) setLoading(false)
    }
  }, [tableId, enableCache])

  useEffect(() => {
    if (!tableId) return
    fetchData()
  }, [tableId, fetchData])

  const mappedFields = useMemo(() => {
    if (!schema) return []
    return applyFieldMappingBatch(schema.fields)
  }, [schema])

  const categorizedFields = useMemo(() => {
    return categorizeFields(mappedFields)
  }, [mappedFields])

  const stats = useMemo(() => {
    const totalRecords = records.length
    const totalFields = mappedFields.length
    
    let mappedCount = 0
    let autoGeneratedCount = 0
    
    mappedFields.forEach(field => {
      if (field.priority >= 50) {
        mappedCount++
      } else {
        autoGeneratedCount++
      }
    })
    
    return {
      totalRecords,
      totalFields,
      mappedFields: mappedCount,
      autoGeneratedFields: autoGeneratedCount
    }
  }, [records, mappedFields])

  const refetch = useCallback(() => fetchData(true), [fetchData])

  return {
    records,
    schema,
    mappedFields,
    categorizedFields,
    loading,
    error,
    refetch,
    stats
  }
}

export function useTableDataByCategory(
  options: UseTableDataOptions & { category: FieldCategory }
) {
  const { category, ...tableDataOptions } = options
  const tableData = useTableData(tableDataOptions)
  
  const categoryFields = useMemo(() => {
    return tableData.categorizedFields[category] || []
  }, [tableData.categorizedFields, category])
  
  const categoryRecords = useMemo(() => {
    return tableData.records.map(record => ({
      ...record,
      fields: Object.fromEntries(
        Object.entries(record.fields).filter(([key]) => 
          categoryFields.some(field => field.dataKey === key)
        )
      )
    }))
  }, [tableData.records, categoryFields])
  
  return {
    ...tableData,
    categoryFields,
    categoryRecords
  }
}

export type { MappedField, FieldCategory, FieldFormat }
